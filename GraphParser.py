# Generated from Graph.g4 by ANTLR 4.7.2
# encoding: utf-8
from antlr4 import *
from io import StringIO
from typing.io import TextIO
import sys


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3&")
        buf.write("t\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7\4\b")
        buf.write("\t\b\4\t\t\t\3\2\3\2\3\2\7\2\26\n\2\f\2\16\2\31\13\2\3")
        buf.write("\2\3\2\3\3\3\3\3\3\3\3\3\3\5\3\"\n\3\3\4\3\4\3\4\3\4\3")
        buf.write("\4\3\4\3\4\3\4\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\5\3\6\3\6")
        buf.write("\3\6\3\6\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3\7\3")
        buf.write("\7\3\7\3\7\3\7\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b")
        buf.write("\3\b\3\b\3\b\5\bT\n\b\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t")
        buf.write("\3\t\3\t\3\t\3\t\3\t\3\t\5\td\n\t\3\t\3\t\3\t\3\t\3\t")
        buf.write("\3\t\3\t\3\t\3\t\7\to\n\t\f\t\16\tr\13\t\3\t\2\3\20\n")
        buf.write("\2\4\6\b\n\f\16\20\2\5\3\2\37#\3\2\3\4\3\2\5\6\2x\2\27")
        buf.write("\3\2\2\2\4!\3\2\2\2\6#\3\2\2\2\b+\3\2\2\2\n\63\3\2\2\2")
        buf.write("\f\67\3\2\2\2\16S\3\2\2\2\20c\3\2\2\2\22\23\5\4\3\2\23")
        buf.write("\24\7\b\2\2\24\26\3\2\2\2\25\22\3\2\2\2\26\31\3\2\2\2")
        buf.write("\27\25\3\2\2\2\27\30\3\2\2\2\30\32\3\2\2\2\31\27\3\2\2")
        buf.write("\2\32\33\7\2\2\3\33\3\3\2\2\2\34\"\5\6\4\2\35\"\5\b\5")
        buf.write("\2\36\"\5\n\6\2\37\"\5\f\7\2 \"\5\16\b\2!\34\3\2\2\2!")
        buf.write("\35\3\2\2\2!\36\3\2\2\2!\37\3\2\2\2! \3\2\2\2\"\5\3\2")
        buf.write("\2\2#$\7\24\2\2$%\7\27\2\2%&\7\t\2\2&\'\5\20\t\2\'(\7")
        buf.write("\13\2\2()\5\20\t\2)*\7\n\2\2*\7\3\2\2\2+,\7\25\2\2,-\7")
        buf.write("\27\2\2-.\7\t\2\2./\5\20\t\2/\60\7\13\2\2\60\61\5\20\t")
        buf.write("\2\61\62\7\n\2\2\62\t\3\2\2\2\63\64\7\26\2\2\64\65\7\27")
        buf.write("\2\2\65\66\5\20\t\2\66\13\3\2\2\2\678\7\34\2\289\7\36")
        buf.write("\2\29:\7\35\2\2:;\5\20\t\2;<\7\31\2\2<=\5\20\t\2=>\7\32")
        buf.write("\2\2>?\5\20\t\2?@\7\33\2\2@A\7\t\2\2AB\5\20\t\2BC\7\13")
        buf.write("\2\2CD\5\20\t\2DE\7\n\2\2E\r\3\2\2\2FG\7\30\2\2GH\7\27")
        buf.write("\2\2HT\t\2\2\2IJ\7\30\2\2JK\7\27\2\2KL\7\t\2\2LM\5\20")
        buf.write("\t\2MN\7\13\2\2NO\5\20\t\2OP\7\13\2\2PQ\5\20\t\2QR\7\n")
        buf.write("\2\2RT\3\2\2\2SF\3\2\2\2SI\3\2\2\2T\17\3\2\2\2UV\b\t\1")
        buf.write("\2VW\t\3\2\2Wd\5\20\t\tXd\7\r\2\2Yd\7\36\2\2Z[\7\f\2\2")
        buf.write("[\\\7\t\2\2\\]\5\20\t\2]^\7\n\2\2^d\3\2\2\2_`\7\t\2\2")
        buf.write("`a\5\20\t\2ab\7\n\2\2bd\3\2\2\2cU\3\2\2\2cX\3\2\2\2cY")
        buf.write("\3\2\2\2cZ\3\2\2\2c_\3\2\2\2dp\3\2\2\2ef\f\n\2\2fg\7\7")
        buf.write("\2\2go\5\20\t\nhi\f\b\2\2ij\t\4\2\2jo\5\20\t\tkl\f\7\2")
        buf.write("\2lm\t\3\2\2mo\5\20\t\bne\3\2\2\2nh\3\2\2\2nk\3\2\2\2")
        buf.write("or\3\2\2\2pn\3\2\2\2pq\3\2\2\2q\21\3\2\2\2rp\3\2\2\2\b")
        buf.write("\27!Scnp")
        return buf.getvalue()


class GraphParser ( Parser ):

    grammarFileName = "Graph.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'+'", "'-'", "'/'", "'*'", "'**'", "';'", 
                     "'('", "')'", "','" ]

    symbolicNames = [ "<INVALID>", "PLUS", "MINUS", "DIV", "MUL", "POWER", 
                      "SEMICO", "L_BRACKET", "R_BRACKET", "COMMA", "ID", 
                      "CONST_ID", "SIN", "COS", "TAN", "LN", "EXP", "SQRT", 
                      "ORIGIN", "SCALE", "ROT", "IS", "COLOR", "TO", "STEP", 
                      "DRAW", "FOR", "FROM", "T1", "RED", "BLACK", "YELLOW", 
                      "GREEN", "BLUE", "WS", "COMMENT", "ErrText" ]

    RULE_program = 0
    RULE_statement = 1
    RULE_statOrigin = 2
    RULE_statScale = 3
    RULE_statRot = 4
    RULE_statFor = 5
    RULE_statColor = 6
    RULE_expr = 7

    ruleNames =  [ "program", "statement", "statOrigin", "statScale", "statRot", 
                   "statFor", "statColor", "expr" ]

    EOF = Token.EOF
    PLUS=1
    MINUS=2
    DIV=3
    MUL=4
    POWER=5
    SEMICO=6
    L_BRACKET=7
    R_BRACKET=8
    COMMA=9
    ID=10
    CONST_ID=11
    SIN=12
    COS=13
    TAN=14
    LN=15
    EXP=16
    SQRT=17
    ORIGIN=18
    SCALE=19
    ROT=20
    IS=21
    COLOR=22
    TO=23
    STEP=24
    DRAW=25
    FOR=26
    FROM=27
    T1=28
    RED=29
    BLACK=30
    YELLOW=31
    GREEN=32
    BLUE=33
    WS=34
    COMMENT=35
    ErrText=36

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.7.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class ProgramContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(GraphParser.EOF, 0)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GraphParser.StatementContext)
            else:
                return self.getTypedRuleContext(GraphParser.StatementContext,i)


        def SEMICO(self, i:int=None):
            if i is None:
                return self.getTokens(GraphParser.SEMICO)
            else:
                return self.getToken(GraphParser.SEMICO, i)

        def getRuleIndex(self):
            return GraphParser.RULE_program

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitProgram" ):
                return visitor.visitProgram(self)
            else:
                return visitor.visitChildren(self)




    def program(self):

        localctx = GraphParser.ProgramContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_program)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 21
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << GraphParser.ORIGIN) | (1 << GraphParser.SCALE) | (1 << GraphParser.ROT) | (1 << GraphParser.COLOR) | (1 << GraphParser.FOR))) != 0):
                self.state = 16
                self.statement()
                self.state = 17
                self.match(GraphParser.SEMICO)
                self.state = 23
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 24
            self.match(GraphParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StatementContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def statOrigin(self):
            return self.getTypedRuleContext(GraphParser.StatOriginContext,0)


        def statScale(self):
            return self.getTypedRuleContext(GraphParser.StatScaleContext,0)


        def statRot(self):
            return self.getTypedRuleContext(GraphParser.StatRotContext,0)


        def statFor(self):
            return self.getTypedRuleContext(GraphParser.StatForContext,0)


        def statColor(self):
            return self.getTypedRuleContext(GraphParser.StatColorContext,0)


        def getRuleIndex(self):
            return GraphParser.RULE_statement

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStatement" ):
                return visitor.visitStatement(self)
            else:
                return visitor.visitChildren(self)




    def statement(self):

        localctx = GraphParser.StatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_statement)
        try:
            self.state = 31
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [GraphParser.ORIGIN]:
                self.enterOuterAlt(localctx, 1)
                self.state = 26
                self.statOrigin()
                pass
            elif token in [GraphParser.SCALE]:
                self.enterOuterAlt(localctx, 2)
                self.state = 27
                self.statScale()
                pass
            elif token in [GraphParser.ROT]:
                self.enterOuterAlt(localctx, 3)
                self.state = 28
                self.statRot()
                pass
            elif token in [GraphParser.FOR]:
                self.enterOuterAlt(localctx, 4)
                self.state = 29
                self.statFor()
                pass
            elif token in [GraphParser.COLOR]:
                self.enterOuterAlt(localctx, 5)
                self.state = 30
                self.statColor()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StatOriginContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ORIGIN(self):
            return self.getToken(GraphParser.ORIGIN, 0)

        def IS(self):
            return self.getToken(GraphParser.IS, 0)

        def L_BRACKET(self):
            return self.getToken(GraphParser.L_BRACKET, 0)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GraphParser.ExprContext)
            else:
                return self.getTypedRuleContext(GraphParser.ExprContext,i)


        def COMMA(self):
            return self.getToken(GraphParser.COMMA, 0)

        def R_BRACKET(self):
            return self.getToken(GraphParser.R_BRACKET, 0)

        def getRuleIndex(self):
            return GraphParser.RULE_statOrigin

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStatOrigin" ):
                return visitor.visitStatOrigin(self)
            else:
                return visitor.visitChildren(self)




    def statOrigin(self):

        localctx = GraphParser.StatOriginContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_statOrigin)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 33
            self.match(GraphParser.ORIGIN)
            self.state = 34
            self.match(GraphParser.IS)
            self.state = 35
            self.match(GraphParser.L_BRACKET)
            self.state = 36
            self.expr(0)
            self.state = 37
            self.match(GraphParser.COMMA)
            self.state = 38
            self.expr(0)
            self.state = 39
            self.match(GraphParser.R_BRACKET)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StatScaleContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SCALE(self):
            return self.getToken(GraphParser.SCALE, 0)

        def IS(self):
            return self.getToken(GraphParser.IS, 0)

        def L_BRACKET(self):
            return self.getToken(GraphParser.L_BRACKET, 0)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GraphParser.ExprContext)
            else:
                return self.getTypedRuleContext(GraphParser.ExprContext,i)


        def COMMA(self):
            return self.getToken(GraphParser.COMMA, 0)

        def R_BRACKET(self):
            return self.getToken(GraphParser.R_BRACKET, 0)

        def getRuleIndex(self):
            return GraphParser.RULE_statScale

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStatScale" ):
                return visitor.visitStatScale(self)
            else:
                return visitor.visitChildren(self)




    def statScale(self):

        localctx = GraphParser.StatScaleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_statScale)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 41
            self.match(GraphParser.SCALE)
            self.state = 42
            self.match(GraphParser.IS)
            self.state = 43
            self.match(GraphParser.L_BRACKET)
            self.state = 44
            self.expr(0)
            self.state = 45
            self.match(GraphParser.COMMA)
            self.state = 46
            self.expr(0)
            self.state = 47
            self.match(GraphParser.R_BRACKET)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StatRotContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ROT(self):
            return self.getToken(GraphParser.ROT, 0)

        def IS(self):
            return self.getToken(GraphParser.IS, 0)

        def expr(self):
            return self.getTypedRuleContext(GraphParser.ExprContext,0)


        def getRuleIndex(self):
            return GraphParser.RULE_statRot

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStatRot" ):
                return visitor.visitStatRot(self)
            else:
                return visitor.visitChildren(self)




    def statRot(self):

        localctx = GraphParser.StatRotContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_statRot)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 49
            self.match(GraphParser.ROT)
            self.state = 50
            self.match(GraphParser.IS)
            self.state = 51
            self.expr(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StatForContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FOR(self):
            return self.getToken(GraphParser.FOR, 0)

        def T1(self):
            return self.getToken(GraphParser.T1, 0)

        def FROM(self):
            return self.getToken(GraphParser.FROM, 0)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GraphParser.ExprContext)
            else:
                return self.getTypedRuleContext(GraphParser.ExprContext,i)


        def TO(self):
            return self.getToken(GraphParser.TO, 0)

        def STEP(self):
            return self.getToken(GraphParser.STEP, 0)

        def DRAW(self):
            return self.getToken(GraphParser.DRAW, 0)

        def L_BRACKET(self):
            return self.getToken(GraphParser.L_BRACKET, 0)

        def COMMA(self):
            return self.getToken(GraphParser.COMMA, 0)

        def R_BRACKET(self):
            return self.getToken(GraphParser.R_BRACKET, 0)

        def getRuleIndex(self):
            return GraphParser.RULE_statFor

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStatFor" ):
                return visitor.visitStatFor(self)
            else:
                return visitor.visitChildren(self)




    def statFor(self):

        localctx = GraphParser.StatForContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_statFor)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 53
            self.match(GraphParser.FOR)
            self.state = 54
            self.match(GraphParser.T1)
            self.state = 55
            self.match(GraphParser.FROM)
            self.state = 56
            self.expr(0)
            self.state = 57
            self.match(GraphParser.TO)
            self.state = 58
            self.expr(0)
            self.state = 59
            self.match(GraphParser.STEP)
            self.state = 60
            self.expr(0)
            self.state = 61
            self.match(GraphParser.DRAW)
            self.state = 62
            self.match(GraphParser.L_BRACKET)
            self.state = 63
            self.expr(0)
            self.state = 64
            self.match(GraphParser.COMMA)
            self.state = 65
            self.expr(0)
            self.state = 66
            self.match(GraphParser.R_BRACKET)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StatColorContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return GraphParser.RULE_statColor

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class BuiltinColorContext(StatColorContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GraphParser.StatColorContext
            super().__init__(parser)
            self.C = None # Token
            self.copyFrom(ctx)

        def COLOR(self):
            return self.getToken(GraphParser.COLOR, 0)
        def IS(self):
            return self.getToken(GraphParser.IS, 0)
        def RED(self):
            return self.getToken(GraphParser.RED, 0)
        def BLACK(self):
            return self.getToken(GraphParser.BLACK, 0)
        def YELLOW(self):
            return self.getToken(GraphParser.YELLOW, 0)
        def GREEN(self):
            return self.getToken(GraphParser.GREEN, 0)
        def BLUE(self):
            return self.getToken(GraphParser.BLUE, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBuiltinColor" ):
                return visitor.visitBuiltinColor(self)
            else:
                return visitor.visitChildren(self)


    class CustomColorContext(StatColorContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GraphParser.StatColorContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def COLOR(self):
            return self.getToken(GraphParser.COLOR, 0)
        def IS(self):
            return self.getToken(GraphParser.IS, 0)
        def L_BRACKET(self):
            return self.getToken(GraphParser.L_BRACKET, 0)
        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GraphParser.ExprContext)
            else:
                return self.getTypedRuleContext(GraphParser.ExprContext,i)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(GraphParser.COMMA)
            else:
                return self.getToken(GraphParser.COMMA, i)
        def R_BRACKET(self):
            return self.getToken(GraphParser.R_BRACKET, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCustomColor" ):
                return visitor.visitCustomColor(self)
            else:
                return visitor.visitChildren(self)



    def statColor(self):

        localctx = GraphParser.StatColorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_statColor)
        self._la = 0 # Token type
        try:
            self.state = 81
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,2,self._ctx)
            if la_ == 1:
                localctx = GraphParser.BuiltinColorContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 68
                self.match(GraphParser.COLOR)
                self.state = 69
                self.match(GraphParser.IS)
                self.state = 70
                localctx.C = self._input.LT(1)
                _la = self._input.LA(1)
                if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << GraphParser.RED) | (1 << GraphParser.BLACK) | (1 << GraphParser.YELLOW) | (1 << GraphParser.GREEN) | (1 << GraphParser.BLUE))) != 0)):
                    localctx.C = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass

            elif la_ == 2:
                localctx = GraphParser.CustomColorContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 71
                self.match(GraphParser.COLOR)
                self.state = 72
                self.match(GraphParser.IS)
                self.state = 73
                self.match(GraphParser.L_BRACKET)
                self.state = 74
                self.expr(0)
                self.state = 75
                self.match(GraphParser.COMMA)
                self.state = 76
                self.expr(0)
                self.state = 77
                self.match(GraphParser.COMMA)
                self.state = 78
                self.expr(0)
                self.state = 79
                self.match(GraphParser.R_BRACKET)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return GraphParser.RULE_expr

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class PowerExprContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GraphParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GraphParser.ExprContext)
            else:
                return self.getTypedRuleContext(GraphParser.ExprContext,i)

        def POWER(self):
            return self.getToken(GraphParser.POWER, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPowerExpr" ):
                return visitor.visitPowerExpr(self)
            else:
                return visitor.visitChildren(self)


    class MulDivExprContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GraphParser.ExprContext
            super().__init__(parser)
            self.op = None # Token
            self.copyFrom(ctx)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GraphParser.ExprContext)
            else:
                return self.getTypedRuleContext(GraphParser.ExprContext,i)

        def MUL(self):
            return self.getToken(GraphParser.MUL, 0)
        def DIV(self):
            return self.getToken(GraphParser.DIV, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMulDivExpr" ):
                return visitor.visitMulDivExpr(self)
            else:
                return visitor.visitChildren(self)


    class VarTContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GraphParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def T1(self):
            return self.getToken(GraphParser.T1, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVarT" ):
                return visitor.visitVarT(self)
            else:
                return visitor.visitChildren(self)


    class ConstContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GraphParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def CONST_ID(self):
            return self.getToken(GraphParser.CONST_ID, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConst" ):
                return visitor.visitConst(self)
            else:
                return visitor.visitChildren(self)


    class PlusMinusExprContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GraphParser.ExprContext
            super().__init__(parser)
            self.op = None # Token
            self.copyFrom(ctx)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GraphParser.ExprContext)
            else:
                return self.getTypedRuleContext(GraphParser.ExprContext,i)

        def PLUS(self):
            return self.getToken(GraphParser.PLUS, 0)
        def MINUS(self):
            return self.getToken(GraphParser.MINUS, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPlusMinusExpr" ):
                return visitor.visitPlusMinusExpr(self)
            else:
                return visitor.visitChildren(self)


    class NestedExprContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GraphParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def L_BRACKET(self):
            return self.getToken(GraphParser.L_BRACKET, 0)
        def expr(self):
            return self.getTypedRuleContext(GraphParser.ExprContext,0)

        def R_BRACKET(self):
            return self.getToken(GraphParser.R_BRACKET, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNestedExpr" ):
                return visitor.visitNestedExpr(self)
            else:
                return visitor.visitChildren(self)


    class UnaryExprContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GraphParser.ExprContext
            super().__init__(parser)
            self.op = None # Token
            self.copyFrom(ctx)

        def expr(self):
            return self.getTypedRuleContext(GraphParser.ExprContext,0)

        def PLUS(self):
            return self.getToken(GraphParser.PLUS, 0)
        def MINUS(self):
            return self.getToken(GraphParser.MINUS, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnaryExpr" ):
                return visitor.visitUnaryExpr(self)
            else:
                return visitor.visitChildren(self)


    class FuncExprContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a GraphParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ID(self):
            return self.getToken(GraphParser.ID, 0)
        def L_BRACKET(self):
            return self.getToken(GraphParser.L_BRACKET, 0)
        def expr(self):
            return self.getTypedRuleContext(GraphParser.ExprContext,0)

        def R_BRACKET(self):
            return self.getToken(GraphParser.R_BRACKET, 0)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFuncExpr" ):
                return visitor.visitFuncExpr(self)
            else:
                return visitor.visitChildren(self)



    def expr(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = GraphParser.ExprContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 14
        self.enterRecursionRule(localctx, 14, self.RULE_expr, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 97
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [GraphParser.PLUS, GraphParser.MINUS]:
                localctx = GraphParser.UnaryExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx

                self.state = 84
                localctx.op = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==GraphParser.PLUS or _la==GraphParser.MINUS):
                    localctx.op = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 85
                self.expr(7)
                pass
            elif token in [GraphParser.CONST_ID]:
                localctx = GraphParser.ConstContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 86
                self.match(GraphParser.CONST_ID)
                pass
            elif token in [GraphParser.T1]:
                localctx = GraphParser.VarTContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 87
                self.match(GraphParser.T1)
                pass
            elif token in [GraphParser.ID]:
                localctx = GraphParser.FuncExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 88
                self.match(GraphParser.ID)
                self.state = 89
                self.match(GraphParser.L_BRACKET)
                self.state = 90
                self.expr(0)
                self.state = 91
                self.match(GraphParser.R_BRACKET)
                pass
            elif token in [GraphParser.L_BRACKET]:
                localctx = GraphParser.NestedExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 93
                self.match(GraphParser.L_BRACKET)
                self.state = 94
                self.expr(0)
                self.state = 95
                self.match(GraphParser.R_BRACKET)
                pass
            else:
                raise NoViableAltException(self)

            self._ctx.stop = self._input.LT(-1)
            self.state = 110
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,5,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 108
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,4,self._ctx)
                    if la_ == 1:
                        localctx = GraphParser.PowerExprContext(self, GraphParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 99
                        if not self.precpred(self._ctx, 8):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 8)")
                        self.state = 100
                        self.match(GraphParser.POWER)
                        self.state = 101
                        self.expr(8)
                        pass

                    elif la_ == 2:
                        localctx = GraphParser.MulDivExprContext(self, GraphParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 102
                        if not self.precpred(self._ctx, 6):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 6)")
                        self.state = 103
                        localctx.op = self._input.LT(1)
                        _la = self._input.LA(1)
                        if not(_la==GraphParser.DIV or _la==GraphParser.MUL):
                            localctx.op = self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 104
                        self.expr(7)
                        pass

                    elif la_ == 3:
                        localctx = GraphParser.PlusMinusExprContext(self, GraphParser.ExprContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 105
                        if not self.precpred(self._ctx, 5):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 5)")
                        self.state = 106
                        localctx.op = self._input.LT(1)
                        _la = self._input.LA(1)
                        if not(_la==GraphParser.PLUS or _la==GraphParser.MINUS):
                            localctx.op = self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 107
                        self.expr(6)
                        pass

             
                self.state = 112
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,5,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx



    def sempred(self, localctx:RuleContext, ruleIndex:int, predIndex:int):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[7] = self.expr_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def expr_sempred(self, localctx:ExprContext, predIndex:int):
            if predIndex == 0:
                return self.precpred(self._ctx, 8)
         

            if predIndex == 1:
                return self.precpred(self._ctx, 6)
         

            if predIndex == 2:
                return self.precpred(self._ctx, 5)
         




